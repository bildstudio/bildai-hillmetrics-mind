@page "/flux/fetching-history"
@using HillMetrics.MIND.API.Contracts.Requests.Flux
@using HillMetrics.MIND.API.Contracts.Responses
@using HillMetrics.MIND.API.Contracts.Responses.Flux
@using HillMetrics.Core.Search
@using HillMetrics.Core
@using HillMetrics.MIND.FrontApp.Services
@using HillMetrics.Normalized.Domain.Contracts.Providing.Flux
@using HillMetrics.MIND.FrontApp.Components.Shared
@using HillMetrics.MIND.API.SDK.V1
@inject IMindAPI MindApi
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@inject IDialogService DialogService

@attribute [Authorize]

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">Flux Fetching History</MudText>

    <MudCard Class="mb-4">
        <MudCardContent>
            <MudForm @ref="form" @bind-IsValid="@isValid">
                <MudGrid Spacing="1">
                    <!-- Flux ID -->
                    <MudItem xs="12" md="6">
                        <SearchCriteriaComponent T="int"
                        SearchCriteria="@fluxIdSearchCriteria"
                        SearchCriteriaChanged="@((criteria) => fluxIdSearchCriteria = criteria)"
                        Label="Flux ID" />
                    </MudItem>

                    <!-- Number of Contents -->
                    <MudItem xs="12" md="6">
                        <SearchCriteriaComponent T="int"
                        SearchCriteria="@nbContentSearchCriteria"
                        SearchCriteriaChanged="@((criteria) => nbContentSearchCriteria = criteria)"
                        Label="Number of Contents" />
                    </MudItem>

                    <!-- Number of Processings -->
                    <MudItem xs="12" md="6">
                        <SearchCriteriaComponent T="int"
                        SearchCriteria="@nbProcessingSearchCriteria"
                        SearchCriteriaChanged="@((criteria) => nbProcessingSearchCriteria = criteria)"
                        Label="Number of Processings" />
                    </MudItem>

                    <!-- External Data ID -->
                    <MudItem xs="12" md="6">
                        <SearchCriteriaComponent T="string"
                        SearchCriteria="@externalDataIdSearchCriteria"
                        SearchCriteriaChanged="@((criteria) => externalDataIdSearchCriteria = criteria)"
                        Label="External Data ID" />
                    </MudItem>

                    <!-- Content Name -->
                    <MudItem xs="12" md="6">
                        <SearchCriteriaComponent T="string"
                        SearchCriteria="@contentNameSearchCriteria"
                        SearchCriteriaChanged="@((criteria) => contentNameSearchCriteria = criteria)"
                        Label="Content Name" />
                    </MudItem>

                    <!-- Raw ID -->
                    <MudItem xs="12" md="6">
                        <SearchCriteriaComponent T="string"
                        SearchCriteria="@rawIdSearchCriteria"
                        SearchCriteriaChanged="@((criteria) => rawIdSearchCriteria = criteria)"
                        Label="Raw ID" />
                    </MudItem>

                    <!-- Metadata -->
                    <MudItem xs="12" md="6">
                        <SearchCriteriaComponent T="string"
                        SearchCriteria="@metadataSearchCriteria"
                        SearchCriteriaChanged="@((criteria) => metadataSearchCriteria = criteria)"
                        Label="Metadata" />
                    </MudItem>

                    <!-- Fetching Date -->
                    <MudItem xs="12" md="6">
                        <SearchCriteriaComponent T="DateTime"
                        SearchCriteria="@fetchingDateSearchCriteria"
                        SearchCriteriaChanged="@((criteria) => fetchingDateSearchCriteria = criteria)"
                        Label="Fetching Date" />
                    </MudItem>

                    <!-- Content Status -->
                    <MudItem xs="12" md="6">
                        <MudSelect T="StatusProcess?" @bind-Value="searchRequest.ContentStatus"
                        Label="Content Status" Variant="Variant.Outlined" Dense="true" Margin="Margin.Dense">
                            <MudSelectItem Value="@((StatusProcess?)null)">All</MudSelectItem>
                            @foreach (var status in Enum.GetValues<StatusProcess>())
                            {
                                <MudSelectItem T="StatusProcess?" Value="@status">@status</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>
                </MudGrid>
            </MudForm>
        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="Search" Size="Size.Small">Search</MudButton>
            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" OnClick="Reset" Size="Size.Small">Reset</MudButton>
        </MudCardActions>
    </MudCard>

    @if (loading)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="my-2" />
    }
    else
    {
        <MudTable ServerData="@ServerReload"
        Hover="true" Bordered="true" Striped="true"
        Dense="true" @bind-SelectedItem="selectedItem" T="FluxFetchingSearchResponse"
        Breakpoint="Breakpoint.Sm">
            <ToolBarContent>
                <MudText Typo="Typo.h6" Class="ml-2">Fetching History</MudText>
                <MudSpacer />
                <MudTextField @bind-Value="searchString" Placeholder="Search" Adornment="Adornment.Start"
                AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium"
                Class="mt-0 mb-3" Margin="Margin.Dense" Dense="true"></MudTextField>
            </ToolBarContent>
            <HeaderContent>
                <MudTh>ID</MudTh>
                <MudTh>Flux ID</MudTh>
                <MudTh>Fetching Date</MudTh>
                <MudTh>Content Name</MudTh>
                <MudTh>External ID</MudTh>
                <MudTh>Contents</MudTh>
                <MudTh>Processings</MudTh>
                <MudTh>Status</MudTh>
                <MudTh>Actions</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="ID">
                    <MudLink Href="@($"/flux/fetching-details/{context.Id}")">@context.Id</MudLink>
                    
                </MudTd>
                <MudTd DataLabel="Flux ID">
                    <MudLink Href="@($"/flux/details/{context.FluxId}")">@context.FluxId</MudLink>
                </MudTd>
                <MudTd DataLabel="Fetching Date">
                    <MudTooltip Text="@context.FetchingDate.ToString("yyyy-MM-dd HH:mm:ss")">
                        <div>@FormatDateTime(context.FetchingDate)</div>
                    </MudTooltip>
                </MudTd>
                <MudTd DataLabel="Content Name">
                    @if (!string.IsNullOrEmpty(context.ContentName))
                    {
                        <MudText Typo="Typo.body2">@context.ContentName</MudText>
                    }
                    else
                    {
                        <span>-</span>
                    }
                </MudTd>
                <MudTd DataLabel="External ID">
                    @if (!string.IsNullOrEmpty(context.ExternalDataId))
                    {
                        <MudTooltip Text="@context.ExternalDataId">
                            <div class="mud-text-truncate" style="max-width: 150px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                @context.ExternalDataId
                            </div>
                        </MudTooltip>
                    }
                    else
                    {
                        <span>-</span>
                    }
                </MudTd>
                <MudTd DataLabel="Contents">
                    <MudBadge Content="@context.NbContent" Color="Color.Primary" Overlap="true" Class="d-flex justify-center"></MudBadge>
                </MudTd>
                <MudTd DataLabel="Processings">
                    <MudBadge Content="@context.NbProcessing" Color="Color.Secondary" Overlap="true" Class="d-flex justify-center"></MudBadge>
                </MudTd>
                <MudTd DataLabel="Status">
                    @if (context.ContentStatus.HasValue)
                    {
                        <MudTooltip Text="@context.ContentStatus.Value.ToString()">
                            <MudIcon Icon="@GetStatusIcon(context.ContentStatus.Value)"
                            Color="@GetStatusColor(context.ContentStatus.Value)" />
                        </MudTooltip>
                    }
                    else
                    {
                        <span>-</span>
                    }
                </MudTd>
                <MudTd DataLabel="Actions">
                    <MudMenu Icon="@Icons.Material.Filled.MoreVert" Size="Size.Small" Dense="true">
                        <MudMenuItem OnClick="@(() => ViewDetails(context.Id))">
                            <MudIcon Icon="@Icons.Material.Filled.Visibility" Class="mr-2" Size="Size.Small" /> View Details
                        </MudMenuItem>
                        <MudMenuItem OnClick="@(() => ViewFluxDetails(context.FluxId))">
                            <MudIcon Icon="@Icons.Material.Filled.Assignment" Class="mr-2" Size="Size.Small" /> View Flux
                        </MudMenuItem>
                        @if (!string.IsNullOrEmpty(context.Metadata))
                        {
                            <MudMenuItem OnClick="@(async () => await ShowMetadata(context))">
                                <MudIcon Icon="@Icons.Material.Filled.Info" Class="mr-2" Size="Size.Small" /> Show Metadata
                            </MudMenuItem>
                        }
                        <MudMenuItem OnClick="@(() => ForceProcess(context.Id))">
                            <MudIcon Icon="@Icons.Material.Filled.PlayArrow" Class="mr-2" Size="Size.Small" /> Force Process
                        </MudMenuItem>
                    </MudMenu>
                </MudTd>
            </RowTemplate>
            <PagerContent>
                <MudTablePager PageSizeOptions="new int[] { 10, 25, 50, 100 }" />
            </PagerContent>
            <NoRecordsContent>
                <MudAlert Severity="Severity.Info" Class="my-2">No fetching history found matching your search criteria.</MudAlert>
            </NoRecordsContent>
        </MudTable>
    }
</MudContainer>

@code {
    private FluxFetchingSearchRequest searchRequest = new();
    private List<FluxFetchingSearchResponse>? fetchingHistories;
    private bool loading = false;
    private bool isValid = false;
    private TableState tableState;
    private MudForm form;
    private string searchString = "";
    private FluxFetchingSearchResponse selectedItem = null;

    // SearchCriteria for each field
    private SearchCriteria<int> fluxIdSearchCriteria = new();
    private SearchCriteria<int> nbContentSearchCriteria = new();
    private SearchCriteria<int> nbProcessingSearchCriteria = new();
    private SearchCriteria<string> externalDataIdSearchCriteria = new();
    private SearchCriteria<string> contentNameSearchCriteria = new();
    private SearchCriteria<string> rawIdSearchCriteria = new();
    private SearchCriteria<string> metadataSearchCriteria = new();
    private SearchCriteria<DateTime> fetchingDateSearchCriteria = new();

    // Dialog for metadata
    private FluxFetchingSearchResponse selectedMetadata = null;

    [Parameter]
    [SupplyParameterFromQuery(Name = "fluxId")]
    public string FluxIdParameter { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // Vérifier si le paramètre FluxId est fourni
        if (!string.IsNullOrEmpty(FluxIdParameter) && int.TryParse(FluxIdParameter, out int fluxId))
        {
            // Initialiser le critère de recherche pour FluxId
            fluxIdSearchCriteria = new SearchCriteria<int>
            {
                Operator = Operator.Equal,
                Value = fluxId
            };
        }
        
        await Search();
    }

    private async Task<TableData<FluxFetchingSearchResponse>> ServerReload(TableState state, CancellationToken token)
    {
        tableState = state;
        loading = true;

        try
        {
            // Apply search criteria
            ApplySearchCriteria();

            // Configurer la pagination
            searchRequest.Pagination = new Pagination(state.PageSize, state.Page + 1);

            var response = await MindApi.SearchFetchingHistoryAsync(searchRequest);
            fetchingHistories = response.Data.ToList();
            
            return new TableData<FluxFetchingSearchResponse>
            {
                Items = fetchingHistories,
                TotalItems = (int)response.TotalRecords
            };
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error searching fetching history: {ex.Message}", Severity.Error);
            return new TableData<FluxFetchingSearchResponse>
            {
                Items = new List<FluxFetchingSearchResponse>(),
                TotalItems = 0
            };
        }
        finally
        {
            loading = false;
            StateHasChanged();
        }
    }

    private void ApplySearchCriteria()
    {
        // Apply numerical SearchCriteria
        searchRequest.FluxId = fluxIdSearchCriteria.IsSet() ? fluxIdSearchCriteria : null;
        searchRequest.NbContent = nbContentSearchCriteria.IsSet() ? nbContentSearchCriteria : null;
        searchRequest.NbProcessing = nbProcessingSearchCriteria.IsSet() ? nbProcessingSearchCriteria : null;

        // Apply string criteria only if they are set
        if (externalDataIdSearchCriteria.IsSet())
        {
            searchRequest.ExternalDataId = externalDataIdSearchCriteria.Value;
        }
        else
        {
            searchRequest.ExternalDataId = null;
        }

        if (contentNameSearchCriteria.IsSet())
        {
            searchRequest.ContentName = contentNameSearchCriteria.Value;
        }
        else
        {
            searchRequest.ContentName = null;
        }

        if (rawIdSearchCriteria.IsSet())
        {
            searchRequest.RawId = rawIdSearchCriteria.Value;
        }
        else
        {
            searchRequest.RawId = null;
        }

        if (metadataSearchCriteria.IsSet())
        {
            searchRequest.Metadata = metadataSearchCriteria.Value;
        }
        else
        {
            searchRequest.Metadata = null;
        }

        // Apply datetime SearchCriteria
        searchRequest.FetchingDate = fetchingDateSearchCriteria.IsSet() ? fetchingDateSearchCriteria : null;
    }

    private async Task Search()
    {
        // Utiliser le state actuel pour recharger les données
        await ServerReload(tableState ?? new TableState
        {
            Page = 0,
            PageSize = 10
        }, CancellationToken.None);
    }

    private async Task Reset()
    {
        searchRequest = new FluxFetchingSearchRequest();
        fluxIdSearchCriteria = new SearchCriteria<int>();
        nbContentSearchCriteria = new SearchCriteria<int>();
        nbProcessingSearchCriteria = new SearchCriteria<int>();
        externalDataIdSearchCriteria = new SearchCriteria<string>();
        contentNameSearchCriteria = new SearchCriteria<string>();
        rawIdSearchCriteria = new SearchCriteria<string>();
        metadataSearchCriteria = new SearchCriteria<string>();
        fetchingDateSearchCriteria = new SearchCriteria<DateTime>();
        searchString = "";
        
        if (tableState != null)
        {
            tableState.Page = 0;
            await ServerReload(tableState, CancellationToken.None);
        }
    }

    private void ViewDetails(int id)
    {
        NavigationManager.NavigateTo($"/flux/fetching-details/{id}");
    }

    private void ViewFluxDetails(int id)
    {
        NavigationManager.NavigateTo($"/flux/details/{id}");
    }

    private async Task ShowMetadata(FluxFetchingSearchResponse history)
    {
        var parameters = new DialogParameters();
        parameters.Add("Metadata", history);
        
        var options = new DialogOptions() 
        {
            CloseOnEscapeKey = true, 
            MaxWidth = MaxWidth.Medium,
            FullWidth = true,
            Position = DialogPosition.Center
        };
        
        await DialogService.ShowAsync<FetchingMetadataDialog>("Fetching Metadata", parameters, options);
    }

    private async Task ForceProcess(int fetchingHistoryId)
    {
        try
        {
            loading = true;
            // Cette fonctionnalité dépendra de votre API - pour l'instant c'est un placeholder
            // var result = await FluxService.ForceProcessFetchingAsync(fetchingHistoryId);
            Snackbar.Add("Force process initiated", Severity.Success);
            await Search();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            loading = false;
        }
    }

    // Helper methods for icons and colors
    private string GetStatusIcon(StatusProcess status)
    {
        return status switch
        {
            StatusProcess.Success => Icons.Material.Filled.CheckCircle,
            StatusProcess.Failure => Icons.Material.Filled.Error,
            StatusProcess.Processing => Icons.Material.Filled.Refresh,
            StatusProcess.Paused => Icons.Material.Filled.Pending,
            StatusProcess.Partially => Icons.Material.Filled.Warning,
            _ => Icons.Material.Filled.HelpOutline
        };
    }

    private Color GetStatusColor(StatusProcess status)
    {
        return status switch
        {
            StatusProcess.Success => Color.Success,
            StatusProcess.Failure => Color.Error,
            StatusProcess.Processing => Color.Info,
            StatusProcess.Paused => Color.Warning,
            StatusProcess.Partially => Color.Secondary,
            _ => Color.Default
        };
    }

    private string FormatDateTime(DateTime dateTime)
    {
        var now = DateTime.Now;
        var diff = now - dateTime;

        if (diff.TotalMinutes < 1)
            return "Just now";
        if (diff.TotalHours < 1)
            return $"{(int)diff.TotalMinutes}m ago";
        if (diff.TotalDays < 1)
            return $"{(int)diff.TotalHours}h ago";
        if (diff.TotalDays < 7)
            return $"{(int)diff.TotalDays}d ago";

        return dateTime.ToString("MMM dd, HH:mm");
    }
} 