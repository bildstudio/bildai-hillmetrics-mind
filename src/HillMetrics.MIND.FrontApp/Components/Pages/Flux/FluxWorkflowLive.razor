@page "/flux/workflow-live/{FluxId:int}"
@page "/flux/workflow-live/{FluxId:int}/{WorkflowId:guid}"
@using HillMetrics.Core.Blazor.AuthModule.Services
@using HillMetrics.Core.Monitoring.Workflow
@using HillMetrics.Core.Workflow
@using HillMetrics.Core.Workflow.Models
@using HillMetrics.MIND.API.Contracts.Responses.Flux
@using HillMetrics.MIND.API.SDK.V1
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Extensions.Options
@using HillMetrics.Core.Authentication.Contracts
@inject IMindAPI MindApi
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject IServiceProvider ServiceProvider
@inject IConfiguration Configuration
@inject ILogger<FluxWorkflowLive> Logger
@* @inject IAuthenticationService AuthService *@
@inject IAuthService AuthService
@implements IAsyncDisposable
@attribute [Authorize]

<div class="workflow-container">
    <div class="d-flex align-center justify-space-between mb-4">
        <MudButton Variant="Variant.Text"
                   Color="Color.Primary"
                   StartIcon="@Icons.Material.Filled.ArrowBack"
                   OnClick="@(() => NavigationManager.NavigateTo("/flux/search"))">
            Back to Search
        </MudButton>

        @if (availableWorkflows.Count > 1)
        {
            <MudSelect T="Guid?" Label="Select Workflow" Value="selectedWorkflowId" ValueChanged="OnWorkflowSelectionChanged"
            Class="ml-4" Style="min-width: 300px;">
                @foreach (var workflow in availableWorkflows)
                {
                    <MudSelectItem Value="@workflow.WorkflowId">
                        @($"Started: {workflow.StartTime.ToLocalTime():g}, Status: {workflow.CurrentStage}")
                    </MudSelectItem>
                }
            </MudSelect>
        }

        <MudButton Variant="Variant.Text"
        Color="Color.Secondary"
        StartIcon="@Icons.Material.Filled.Refresh"
        OnClick="@RefreshData">
            Refresh
        </MudButton>
    </div>

    <MudPaper Class="pa-4 mb-4">
        <MudGrid>
            <MudItem xs="12" md="6">
                <MudText Typo="Typo.h6">Flux: @(WorkflowDetails?.FluxName ?? $"ID: {FluxId}")</MudText>
                @if (WorkflowDetails != null)
                {
                    <MudText Typo="Typo.body2">Status: <strong>@WorkflowDetails.CurrentStage</strong></MudText>
                    <MudText Typo="Typo.body2">Started: <strong>@WorkflowDetails.StartTime.ToLocalTime().ToString("g")</strong></MudText>
                    <MudText Typo="Typo.body2">Duration: <strong>@Math.Round(WorkflowDetails.DurationMinutes, 1) min</strong></MudText>
                    <MudText Typo="Typo.body2">WorkflowId: <strong>@WorkflowDetails.WorkflowId</strong></MudText>
                }
            </MudItem>
            <MudItem xs="12" md="6">
                <MudProgressLinear Color="@GetProgressColor(WorkflowDetails?.CurrentStage)"
                Value="@(WorkflowDetails?.ProgressPercentage ?? 0)"
                Class="my-4"
                Size="Size.Large" />
                <MudText Typo="Typo.body2" Align="Align.Center">
                    @(WorkflowDetails?.IsCompleted == true
                            ? (WorkflowDetails?.IsSuccessful == true ? "Completed successfully" : "Failed")
                            : "In progress...")
                </MudText>
            </MudItem>
        </MudGrid>
    </MudPaper>

    <div class="workflow-canvas" @ref="canvasRef">
        @if (WorkflowDetails != null)
        {
            @foreach (var step in positionedSteps)
            {
                var metricsTitle = "";
                if (step.RowsAdded > 0 || step.RowsModified > 0 || step.RowsIgnored > 0 || step.RowsWithErrors > 0)
                {
                    var metrics = new List<string>();
                    if (step.RowsAdded > 0) metrics.Add($"{step.RowsAdded} added");
                    if (step.RowsModified > 0) metrics.Add($"{step.RowsModified} updated");
                    if (step.RowsIgnored > 0) metrics.Add($"{step.RowsIgnored} ignored");
                    if (step.RowsWithErrors > 0) metrics.Add($"{step.RowsWithErrors} errors");
                    metricsTitle = string.Join(", ", metrics);
                }

                <div class="workflow-step @GetStepStatusClass(step.Stage)"
                style="left: @(step.X)px; top: @(step.Y)px; width: 200px;"
                @onclick="@(() => SelectStep(step))"
                title="@($"{step.Stage} - {step.Description}\n{metricsTitle}")">
                    <div class="step-header">
                        @if (IsCompletedStage(step.Stage))
                        {
                            <i class="mud-icon-root mud-icon-default mud-icon-size-small mud-color-success" aria-hidden="true">
                                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px;"><path d="M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z" fill="currentColor"></path></svg>
                            </i>
                        }
                        else if (step.Stage.Contains("Failed"))
                        {
                            <i class="mud-icon-root mud-icon-default mud-icon-size-small mud-color-error" aria-hidden="true">
                                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px;"><path d="M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" fill="currentColor"></path></svg>
                            </i>
                        }
                        else
                        {
                            <i class="mud-icon-root mud-icon-default mud-icon-size-small mud-color-info" aria-hidden="true">
                                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px;"><path d="M12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22C6.47,22 2,17.5 2,12A10,10 0 0,1 12,2M12.5,7V12.25L17,14.92L16.25,16.15L11,13V7H12.5Z" fill="currentColor"></path></svg>
                            </i>
                        }
                        <span>@step.Stage</span>
                    </div>
                    <div class="step-content">@step.Description</div>
                    <div class="step-metrics">
                        @if (step.RowsAdded > 0)
                        {
                            <span class="badge success">+@step.RowsAdded</span>
                        }
                        @if (step.RowsModified > 0)
                        {
                            <span class="badge info">~@step.RowsModified</span>
                        }
                        @if (step.RowsIgnored > 0)
                        {
                            <span class="badge warning">@step.RowsIgnored</span>
                        }
                        @if (step.RowsWithErrors > 0)
                        {
                            <span class="badge error">!@step.RowsWithErrors</span>
                        }
                    </div>
                    <div class="step-timestamp">@step.Timestamp.ToLocalTime().ToString("g")</div>
                </div>
            }

            <svg class="workflow-connections">
                @for (int i = 0; i < positionedSteps.Count - 1; i++)
                {
                    var currentStep = positionedSteps[i];
                    var nextStep = positionedSteps[i + 1];

                    var fromX = currentStep.X + 200;
                    var fromY = currentStep.Y + 40;
                    var toX = nextStep.X;
                    var toY = nextStep.Y + 40;

                    var controlPoint1X = fromX + 50;
                    var controlPoint1Y = fromY;
                    var controlPoint2X = toX - 50;
                    var controlPoint2Y = toY;

                    var pathClass = IsCompletedStage(currentStep.Stage) && IsCompletedStage(nextStep.Stage) 
                        ? "path-completed" 
                        : "path-inprogress";

                    <path d="M @fromX,@fromY C @controlPoint1X,@controlPoint1Y @controlPoint2X,@controlPoint2Y @toX,@toY"
                      fill="none" class="@pathClass" />
                    
                    <circle cx="@toX" cy="@toY" r="5" class="@pathClass" />
                }
            </svg>
        }
        else
        {
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
        }
    </div>

    @if (SelectedStep != null)
    {
        <MudPaper Class="mt-4 pa-4">
            <MudText Typo="Typo.h6">Step Details</MudText>
            <MudList T="HistoryEntryDto" Dense="true">
                <MudListItem>
                    <MudText><b>Stage:</b> @SelectedStep.Stage</MudText>
                </MudListItem>
                <MudListItem>
                    <MudText><b>Description:</b> @SelectedStep.Description</MudText>
                </MudListItem>
                <MudListItem>
                    <MudText><b>Timestamp:</b> @SelectedStep.Timestamp.ToLocalTime().ToString("g")</MudText>
                </MudListItem>
                <MudListItem>
                    <MudText><b>Time since start:</b> @Math.Round(SelectedStep.TimeSinceStart, 1) min</MudText>
                </MudListItem>

                <MudDivider Class="my-2" />
                <MudListItem>
                    <MudText Typo="Typo.subtitle2">Data Metrics</MudText>
                </MudListItem>

                <MudListItem>
                    <MudChip Color="@(SelectedStep.RowsAdded > 0 ? Color.Success : Color.Default)" 
                             Size="Size.Small" Class="mr-2">@SelectedStep.RowsAdded</MudChip>
                    <MudText>Records added</MudText>
                </MudListItem>

                <MudListItem>
                    <MudChip Color="@(SelectedStep.RowsModified > 0 ? Color.Primary : Color.Default)" 
                             Size="Size.Small" Class="mr-2">@SelectedStep.RowsModified</MudChip>
                    <MudText>Records updated</MudText>
                </MudListItem>

                <MudListItem>
                    <MudChip Color="@(SelectedStep.RowsIgnored > 0 ? Color.Warning : Color.Default)" 
                             Size="Size.Small" Class="mr-2">@SelectedStep.RowsIgnored</MudChip>
                    <MudText>Records ignored</MudText>
                </MudListItem>

                <MudListItem>
                    <MudChip Color="@(SelectedStep.RowsWithErrors > 0 ? Color.Error : Color.Default)" 
                             Size="Size.Small" Class="mr-2">@SelectedStep.RowsWithErrors</MudChip>
                    <MudText>Records with errors</MudText>
                </MudListItem>
            </MudList>
        </MudPaper>
    }
</div>

@code {
    [Parameter] public int FluxId { get; set; }
    [Parameter] public Guid? WorkflowId { get; set; }

    private ElementReference canvasRef;
    private FluxWorkflowDetailsDto? WorkflowDetails { get; set; }
    private HistoryEntryDto? SelectedStep { get; set; }
    private HubConnection? hubConnection;
    private List<FluxWorkflowDetailsDto> availableWorkflows = new();
    private Guid? selectedWorkflowId;
    private List<PositionedHistoryEntry> positionedSteps = new();
    private string? signalRServiceUrl;

    private class PositionedHistoryEntry : HistoryEntryDto
    {
        public double X { get; set; }
        public double Y { get; set; }

        public PositionedHistoryEntry(HistoryEntryDto entry, double x, double y)
        {
            // Copier toutes les propriétés
            Stage = entry.Stage;
            Description = entry.Description;
            Timestamp = entry.Timestamp;
            TimeSinceStart = entry.TimeSinceStart;
            RowsAdded = entry.RowsAdded;
            RowsModified = entry.RowsModified;
            RowsIgnored = entry.RowsIgnored;
            RowsWithErrors = entry.RowsWithErrors;
            X = x;
            Y = y;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        selectedWorkflowId = WorkflowId;

        // Récupérer l'URL du service SignalR depuis la configuration ou service discovery
        await GetSignalRServiceUrl();

        await SetupSignalRConnection();
        await RefreshData();
    }

    private async Task GetSignalRServiceUrl()
    {
        try
        {
            // Tenter de récupérer l'URL du service SignalR depuis la configuration
            signalRServiceUrl = Configuration["Services:SignalR:BaseUrl"];

            if (string.IsNullOrEmpty(signalRServiceUrl))
            {
                // Utiliser une URL par défaut si non trouvée dans la configuration
                signalRServiceUrl = "https://localhost:7228";
                Logger.LogInformation($"Using default SignalR service URL: {signalRServiceUrl}");
            }
            else
            {
                Logger.LogInformation($"Found SignalR service URL in configuration: {signalRServiceUrl}");
            }

            // Vérifier si l'URL se termine par un slash
            if (!signalRServiceUrl.EndsWith("/"))
            {
                signalRServiceUrl += "/";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error getting SignalR service URL: {ex.Message}");
            // Fallback sur une URL par défaut en cas d'erreur
            signalRServiceUrl = "https://localhost:8080/";
        }
    }

    private async Task SetupSignalRConnection()
    {
        try
        {
            Logger.LogInformation($"Connecting to SignalR hub at: {signalRServiceUrl}notification-hub");

            // Récupérer un jeton d'accès pour l'authentification
            var accessToken = await GetAccessTokenAsync();

            hubConnection = new HubConnectionBuilder()
                .WithUrl($"{signalRServiceUrl}notification-hub", options =>
                {
                    // Ajouter le jeton d'accès comme en-tête d'autorisation
                    options.AccessTokenProvider = () => Task.FromResult(accessToken);

                    // Configurer d'autres options si nécessaire
                    options.SkipNegotiation = false;
                    options.Transports = Microsoft.AspNetCore.Http.Connections.HttpTransportType.WebSockets;
                })
                .WithAutomaticReconnect(new[] { TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) })
                .Build();

            // S'abonner aux messages de notification
            hubConnection.On<object>("onTopicNotification", (message) =>
            {
                // Cette méthode est appelée lorsqu'un message est reçu sur un topic
                ProcessWorkflowMessage(message);
            });

            // Démarrer la connexion
            await hubConnection.StartAsync();
            Logger.LogInformation("SignalR connection started successfully");

            // S'abonner au topic "workflow" pour recevoir les mises à jour de workflow
            await hubConnection.InvokeAsync("Subscribe", "workflow");
            Logger.LogInformation("Subscribed to 'workflow' topic");

            // Forcer le rafraîchissement initial des données via l'API
            await RefreshDataFromApi();
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error setting up SignalR connection: {ex.Message}");
            // Fallback à l'API REST en cas d'erreur de connexion SignalR
            await RefreshDataFromApi();
        }
    }

    private async Task<string> GetAccessTokenAsync()
    {
        try
        {
            // Utiliser le service d'authentification injecté pour obtenir le jeton
            var token = await AuthService.GetAccessTokenAsync();

            if (!string.IsNullOrEmpty(token))
            {
                Logger.LogInformation("Retrieved token from AuthenticationService");
                return token;
            }

            // Option de secours : Utiliser JSRuntime pour récupérer le jeton stocké côté client
            token = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "auth_token");

            if (!string.IsNullOrEmpty(token))
            {
                Logger.LogInformation("Retrieved token from localStorage");
                return token;
            }

            // Si aucun jeton n'est trouvé, renvoyer null ou une chaîne vide
            Logger.LogError("No access token found");
            return string.Empty;
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error getting access token: {ex.Message}");
            return string.Empty;
        }
    }

    private void ProcessWorkflowMessage(object message)
    {
        try
        {
            // Convertir le message en JSON pour faciliter l'extraction des propriétés
            var json = System.Text.Json.JsonSerializer.Serialize(message);
            var jsonDoc = System.Text.Json.JsonDocument.Parse(json);

            // Tenter d'extraire les informations pertinentes du message
            if (jsonDoc.RootElement.TryGetProperty("Value", out var valueElement))
            {
                // Extraire les propriétés importantes
                if (valueElement.TryGetProperty("FluxId", out var fluxIdElement) &&
                    int.TryParse(fluxIdElement.ToString(), out var fluxId))
                {
                    // Vérifier si ce message concerne notre flux actuel
                    if (fluxId == FluxId)
                    {
                        Logger.LogInformation($"Received workflow update for flux {fluxId}");

                        // Si un WorkflowId est présent, l'extraire
                        Guid? workflowId = null;
                        if (valueElement.TryGetProperty("WorkflowId", out var workflowIdElement) &&
                            Guid.TryParse(workflowIdElement.ToString(), out var parsedWorkflowId))
                        {
                            workflowId = parsedWorkflowId;
                            Logger.LogInformation($"Message contains WorkflowId: {workflowId}");
                        }

                        // Si le message a un indicateur d'erreur
                        bool isError = false;
                        if (valueElement.TryGetProperty("IsError", out var isErrorElement))
                        {
                            isError = isErrorElement.GetBoolean();
                        }

                        // Déclencher un rafraîchissement des données basé sur le message reçu
                        InvokeAsync(async () =>
                        {
                            // Si le message contient un WorkflowId spécifique et qu'il correspond à notre sélection actuelle
                            if (workflowId.HasValue &&
                                (selectedWorkflowId == null || selectedWorkflowId.Value == workflowId.Value))
                            {
                                // Mettre à jour ce workflow spécifique
                                await RefreshDataFromApi();
                            }
                            else
                            {
                                // Sinon rafraîchir toutes les données
                                await RefreshDataFromApi();
                            }

                            StateHasChanged();
                        });
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error processing workflow message: {ex.Message}");
        }
    }

    private async Task RefreshData()
    {
        try
        {
            if (hubConnection != null && hubConnection.State == HubConnectionState.Connected)
            {
                Logger.LogInformation("Refreshing data via SignalR connection");

                // Demander les données via SignalR
                await hubConnection.InvokeAsync("getWorkflowsForFlux", FluxId);

                if (selectedWorkflowId.HasValue)
                {
                    await hubConnection.InvokeAsync("getWorkflowById", selectedWorkflowId.Value);
                }
                else
                {
                    await hubConnection.InvokeAsync("getFluxDetails", FluxId);
                }
                return;
            }

            // Fallback API si SignalR n'est pas disponible
            Logger.LogInformation("Refreshing data via API (SignalR not available)");
            await RefreshDataFromApi();
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error refreshing workflow data: {ex.Message}");
            await RefreshDataFromApi();
        }
    }

    private async Task RefreshDataFromApi()
    {
        try
        {
            if (selectedWorkflowId.HasValue)
            {
                // Récupérer les détails du workflow spécifique
                var response = await MindApi.GetWorkflowByIdAsync(selectedWorkflowId.Value);
                if (response?.Data != null)
                {
                    Logger.LogInformation($"[API update] Received data from GetWorkflowByIdAsync({selectedWorkflowId.Value}), values : {System.Text.Json.JsonSerializer.Serialize(response)}");

                    WorkflowDetails = response.Data;
                    PositionWorkflowSteps();
                }
            }
            else
            {
                // Récupérer les détails globaux du flux
                var response = await MindApi.GetFluxWorkflowDetailsAsync(FluxId);
                if (response?.Data != null)
                {
                    WorkflowDetails = response.Data;
                    PositionWorkflowSteps();
                }
            }

            // Récupérer aussi les workflows actifs et complétés
            var activeResponse = await MindApi.GetActiveFluxesAsync();
            if (activeResponse?.Data != null)
            {
                var relevantWorkflows = activeResponse.Data
                    .Where(f => f.FluxId == FluxId)
                    .ToList();

                // Convertir en FluxWorkflowDetailsDto et mettre à jour la liste
                foreach (var flux in relevantWorkflows)
                {
                    var dto = new FluxWorkflowDetailsDto
                        {
                            FluxId = flux.FluxId,
                            FluxName = flux.FluxName,
                            CurrentStage = flux.Stage,
                            StartTime = flux.StartTime,
                            LastUpdateTime = flux.LastUpdateTime,
                            DurationMinutes = flux.DurationMinutes,
                            ProgressPercentage = flux.ProgressPercentage
                        };

                    // Ajouter ou mettre à jour dans la liste
                    var existingIndex = availableWorkflows.FindIndex(w => w.WorkflowId == dto.WorkflowId);
                    if (existingIndex >= 0)
                    {
                        availableWorkflows[existingIndex] = dto;
                    }
                    else
                    {
                        availableWorkflows.Add(dto);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error refreshing data from API: {ex.Message}");
        }
    }

    private void MapWorkflowStateToDetails(WorkflowStateModel state)
    {
        WorkflowDetails = MapToFluxWorkflowDetailsDto(state);
    }

    private FluxWorkflowDetailsDto MapToFluxWorkflowDetailsDto(WorkflowStateModel state)
    {
        // Convertir WorkflowStateModel en FluxWorkflowDetailsDto
        return new FluxWorkflowDetailsDto
            {
                WorkflowId = state.WorkflowId,
                FluxId = state.FluxId,
                FluxName = state.FluxName,
                CurrentStage = state.CurrentStage.ToString(),
                StageDetails = state.Steps.LastOrDefault()?.Description,
                StartTime = state.StartTime,
                LastUpdateTime = state.LastUpdateTime,
                EndTime = state.EndTime,
                DurationMinutes = state.Duration.TotalMinutes,
                ProgressPercentage = state.ProgressPercentage,
                IsCompleted = state.IsCompleted,
                IsSuccessful = state.IsSuccessful,
                History = state.Steps.Select(s => new HistoryEntryDto
                {
                    Stage = s.Stage.ToString(),
                    Description = s.Description,
                    Timestamp = s.Timestamp,
                    TimeSinceStart = (s.Timestamp - state.StartTime).TotalMinutes,
                    RowsAdded = s.LinesAdded,
                    RowsModified = s.LinesModified,
                    RowsIgnored = s.LinesIgnored,
                    RowsWithErrors = s.LinesWithErrors
                }).ToList()
            };
    }

    private void PositionWorkflowSteps()
    {
        if (WorkflowDetails?.History == null) return;

        // Calculer la position de chaque étape du workflow
        var horizontalSpacing = 250;
        var verticalSpacing = 150;
        var steps = WorkflowDetails.History.OrderBy(h => h.Timestamp).ToList();

        positionedSteps.Clear();
        for (int i = 0; i < steps.Count; i++)
        {
            positionedSteps.Add(new PositionedHistoryEntry(
                steps[i],
                i * horizontalSpacing,
                (i % 2) * verticalSpacing
            ));
        }
    }

    private string GetStepStatusClass(string stage)
    {
        // Parse the stage string to the enum if possible
        if (Enum.TryParse<WorkflowStage>(stage, out var workflowStage))
        {
            return workflowStage switch
            {
                WorkflowStage.Failed => "status-error",
                WorkflowStage.Completed => "status-success",
                
                // Completed stages
                WorkflowStage.FetchingDataCompleted => "status-completed status-info",
                WorkflowStage.ProcessingCompleted => "status-completed status-warning",
                WorkflowStage.NormalizedDataInserted => "status-completed status-secondary",
                WorkflowStage.RefinedDataCopied => "status-completed status-secondary",
                WorkflowStage.CalculationsCompleted => "status-completed status-tertiary",
                
                // In-progress stages
                WorkflowStage.FetchingData => "status-inprogress status-info",
                WorkflowStage.Processing => "status-inprogress status-warning",
                WorkflowStage.RefinedDataCopying => "status-inprogress status-secondary",
                WorkflowStage.CalculationsStarting => "status-inprogress status-tertiary",
                
                // Default or NotStarted
                _ => "status-default"
            };
        }
        
        // Fallback to string-based detection if enum parsing fails
        return stage.ToLowerInvariant() switch
        {
            var s when s.Contains("fail") => "status-error",
            var s when s.Contains("completed") => "status-success",
            var s when s.Contains("processing") => "status-warning",
            var s when s.Contains("fetching") => "status-info",
            var s when s.Contains("insert") => "status-secondary",
            var s when s.Contains("copying") => "status-secondary",
            var s when s.Contains("calculation") => "status-tertiary",
            _ => "status-default"
        };
    }

    private bool IsCompletedStage(string stage)
    {
        // Check if the stage indicates a completed state
        if (Enum.TryParse<WorkflowStage>(stage, out var workflowStage))
        {
            return workflowStage switch
            {
                WorkflowStage.Completed => true,
                WorkflowStage.FetchingDataCompleted => true,
                WorkflowStage.ProcessingCompleted => true,
                WorkflowStage.NormalizedDataInserted => true,
                WorkflowStage.RefinedDataCopied => true,
                WorkflowStage.CalculationsCompleted => true,
                _ => false
            };
        }
        
        // Fallback to string-based detection
        return stage.ToLowerInvariant().Contains("completed") ||
               stage.ToLowerInvariant().Contains("inserted") ||
               stage.ToLowerInvariant().Contains("copied");
    }

    private Color GetProgressColor(string? stage)
    {
        if (string.IsNullOrEmpty(stage)) return Color.Default;

        return stage.ToLowerInvariant() switch
        {
            var s when s.Contains("fail") => Color.Error,
            var s when s.Contains("completed") => Color.Success,
            var s when s.Contains("processing") => Color.Info,
            _ => Color.Primary
        };
    }

    private void SelectStep(HistoryEntryDto step)
    {
        SelectedStep = step;
    }

    private async Task OnWorkflowSelectionChanged(Guid? workflowId)
    {
        selectedWorkflowId = workflowId;

        // Mettre à jour l'URL pour refléter le workflow sélectionné
        if (workflowId.HasValue)
        {
            NavigationManager.NavigateTo($"/flux/workflow-live/{FluxId}/{workflowId}", false);

            // Mise à jour du paramètre WorkflowId
            WorkflowId = workflowId;

            // Rafraîchir les données pour ce workflow spécifique
            await RefreshSpecificWorkflow(workflowId.Value);
        }
        else
        {
            NavigationManager.NavigateTo($"/flux/workflow-live/{FluxId}", false);
            WorkflowId = null;

            // Rafraîchir les données générales du flux
            await RefreshFluxData();
        }
    }

    private async Task RefreshSpecificWorkflow(Guid workflowId)
    {
        try
        {
            // Récupérer les détails du workflow spécifique
            var response = await MindApi.GetWorkflowByIdAsync(workflowId);
            if (response?.Data != null)
            {
                WorkflowDetails = response.Data;
                PositionWorkflowSteps();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error refreshing specific workflow {workflowId}: {ex.Message}");
        }
    }

    private async Task RefreshFluxData()
    {
        try
        {
            // Récupérer les détails globaux du flux
            var response = await MindApi.GetFluxWorkflowDetailsAsync(FluxId);
            if (response?.Data != null)
            {
                WorkflowDetails = response.Data;
                PositionWorkflowSteps();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError($"Error refreshing flux data for FluxId {FluxId}: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection != null)
        {
            // Se désabonner du topic avant de fermer la connexion
            try
            {
                if (hubConnection.State == HubConnectionState.Connected)
                {
                    await hubConnection.InvokeAsync("Unsubscribe", "workflow");
                    Logger.LogInformation("Unsubscribed from 'workflow' topic");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"Error unsubscribing from topic: {ex.Message}");
            }

            await hubConnection.DisposeAsync();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Initialize animations or other JS interop needed after first render
            // await JSRuntime.InvokeVoidAsync("initWorkflowAnimations");
        }
        else if (WorkflowDetails != null)
        {
            // Update animations when workflow data changes
            // await JSRuntime.InvokeVoidAsync("updateWorkflowAnimations");
        }
    }
}

<style>
    .workflow-container {
        position: relative;
        width: 100%;
        height: 600px;
        overflow: auto;
        background-color: #f5f5f5;
        border-radius: 8px;
        padding: 20px;
    }

    .workflow-canvas {
        position: relative;
        width: 100%;
        height: 100%;
        min-height: 100%;
    }

    .workflow-step {
        position: absolute;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        padding: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .workflow-step:hover {
        transform: scale(1.02);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .step-header {
        font-weight: bold;
        margin-bottom: 8px;
        color: #333;
        display: flex;
        align-items: center;
    }

    .step-header i {
        margin-right: 5px;
    }

    .step-content {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 8px;
    }

    .step-metrics {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-bottom: 8px;
        min-height: 22px;
    }

    .badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 12px;
        font-size: 0.75em;
        font-weight: bold;
        color: white;
    }

    .badge.success {
        background-color: #4CAF50;
    }

    .badge.info {
        background-color: #2196F3;
    }

    .badge.warning {
        background-color: #FFC107;
    }

    .badge.error {
        background-color: #F44336;
    }

    /* Enhance badges in completed steps */
    .status-completed .badge {
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    /* Make badges a bit more prominent on hover */
    .workflow-step:hover .badge {
        transform: scale(1.1);
        transition: transform 0.2s ease;
    }

    .step-timestamp {
        font-size: 0.8em;
        color: #999;
    }

    .workflow-connections {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .step-details-panel {
        position: fixed;
        right: 20px;
        top: 20px;
        width: 300px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        z-index: 1000;
    }

    /* Status classes for workflow steps */
    .status-default {
        border-left: 4px solid #ccc;
    }

    .status-info {
        border-left: 4px solid #2196F3;
    }

    .status-success {
        border-left: 4px solid #4CAF50;
    }

    .status-warning {
        border-left: 4px solid #FFC107;
    }

    .status-error {
        border-left: 4px solid #F44336;
    }

    .status-secondary {
        border-left: 4px solid #9C27B0;
    }

    .status-tertiary {
        border-left: 4px solid #FF9800;
    }

    /* Status modifiers for completed vs in-progress */
    .status-completed {
        background-color: rgba(76, 175, 80, 0.1);
    }

    .status-inprogress {
        background-color: rgba(33, 150, 243, 0.05);
        border-style: dashed;
    }

    /* Path styling */
    path {
        transition: stroke 0.3s ease;
    }

    circle {
        transition: fill 0.3s ease;
    }

    .path-completed {
        stroke: #4CAF50;
        stroke-width: 3px;
        fill: #4CAF50;
    }

    .path-inprogress {
        stroke: #888;
        stroke-width: 2px;
        stroke-dasharray: 5,5;
        fill: #888;
    }

    .path-inprogress.animate {
        animation: dash 2s linear infinite;
    }
</style>
